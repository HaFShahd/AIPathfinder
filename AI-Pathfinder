import numpy as np
import matplotlib.pyplot as plt
import heapq
from collections import deque

ROWS, COLS = 10, 10
DELAY = 0.25


MOVES = [
    (-1, 0),   # Up
    (0, 1),    # Right
    (1, 0),    # Bottom
    (1, 1),    # Bottom-Right
    (0, -1),   # Left
    (-1, -1)   # Top-Left
]

def create_grid():
    grid = np.zeros((ROWS, COLS), dtype=int)
    # Vertical wall
    for r in range(1, ROWS-1):
        grid[r][5] = -1
    return grid

def in_bounds(r, c):
    return 0 <= r < ROWS and 0 <= c < COLS

def get_neighbors(node, grid):
    r, c = node
    nbrs = []
    for dr, dc in MOVES:
        nr, nc = r + dr, c + dc
        if in_bounds(nr, nc) and grid[nr][nc] != -1:
            nbrs.append((nr, nc))
    return nbrs

def draw_grid(grid, start, goal, frontier, explored, path, title="Search"):
    plt.clf()
    ax = plt.gca()
    ax.set_aspect('equal')

    for r in range(ROWS):
        for c in range(COLS):
            color = "white"  
            text = str(grid[r][c])  

            if grid[r][c] == -1:
                color = "red"
                text = "-1"
            if (r, c) in frontier:
                color = "yellow"
            if (r, c) in explored:
                color = "lightblue"
            if (r, c) in path:
                color = "green"

            ax.add_patch(plt.Rectangle((c, r), 1, 1, facecolor=color, edgecolor='black'))

            # Draw numbers inside cells
            if (r, c) == start:
                text = "S"
            elif (r, c) == goal:
                text = "T"

            ax.text(c + 0.5, r + 0.5, text, ha="center", va="center", fontsize=10, weight="bold",
                    color="white" if color in ["red", "darkgreen", "blue"] else "black")

    sr, sc = start
    gr, gc = goal
    ax.add_patch(plt.Rectangle((sc, sr), 1, 1, facecolor="darkgreen", edgecolor='black'))
    ax.add_patch(plt.Rectangle((gc, gr), 1, 1, facecolor="blue", edgecolor='black'))

    ax.set_xlim(0, COLS)
    ax.set_ylim(0, ROWS)
    ax.set_xticks(range(COLS+1))
    ax.set_yticks(range(ROWS+1))
    ax.invert_yaxis()
    ax.grid(True)
    ax.set_title(title)
    plt.pause(DELAY)


def build_path(parent, start, goal):
    path = []
    node = goal
    while node is not None:
        path.append(node)
        node = parent.get(node)
    path.reverse()
    return path


def bfs(grid, start, goal):
    queue = deque([start])
    visited = {start}
    parent = {start: None}
    frontier = {start}
    explored = set()

    while queue:
        node = queue.popleft()
        frontier.discard(node)
        explored.add(node)

        if node == goal:
            return build_path(parent, start, goal)

        for nbr in get_neighbors(node, grid):
            if nbr not in visited:
                visited.add(nbr)
                parent[nbr] = node
                queue.append(nbr)
                frontier.add(nbr)

        draw_grid(grid, start, goal, frontier, explored, [], "BFS")
    return None
def dfs(grid, start, goal):
    stack = [start]
    visited = set()
    parent = {start: None}
    frontier = {start}
    explored = set()

    while stack:
        node = stack.pop()
        frontier.discard(node)

        if node == goal:
            return build_path(parent, start, goal)

        if node not in visited:
            visited.add(node)
            explored.add(node)

            for nbr in get_neighbors(node, grid):
                if nbr not in visited:
                    parent[nbr] = node
                    stack.append(nbr)
                    frontier.add(nbr)

        draw_grid(grid, start, goal, frontier, explored, [], "DFS")
    return None
